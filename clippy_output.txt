    Checking rust_flow v0.1.0 (/Users/coryvogan/Documents/Dev/RustFlow)
error: an inner attribute is not permitted in this context
 --> /Users/coryvogan/Documents/Dev/RustFlow/target/debug/build/rust_flow-a0feea827bc94c19/out/integrations.rs:1:1
  |
1 | # ! [allow (clippy :: possible_missing_else)] pub mod slack { # [allow (unused_imports)]...Request failed: {}" , e) ; } } } } } Ok (()) } } } pu...
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ------------------------------------------...-------------------------------------------------- the inner attribute doesn't annotate this module
  |
  = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files
help: to annotate the module, change the attribute from inner to outer style
  |
1 | #! [allow (clippy :: possible_missing_else)] pub mod slack { # [allow (unused_imports)] use super :: * ; pub struct SlackPostMessage { client : reqwest :: Client , } impl Default for SlackPostMessage { fn default () -> Self { Self :: new () } } impl SlackPostMessage { pub fn new () -> Self { Self { client : reqwest :: Client :: new () , } } } # [async_trait :: async_trait] impl crate :: stream_engine :: StreamNode for SlackPostMessage { async fn run (& self , # [allow (unused_mut)] mut _inputs : Vec < tokio :: sync :: mpsc :: Receiver < serde_json :: Value >> , outputs : Vec < tokio :: sync :: mpsc :: Sender < serde_json :: Value >> ,) -> anyhow :: Result < () > { let env = minijinja :: Environment :: new () ; if let Some (rx) = _inputs . get_mut (0) { if let Some (tx) = outputs . first () { while let Some (data) = rx . recv () . await { let url_template = "https://slack.com/api/chat.postMessage" ; let url = env . render_str (url_template , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render URL template: {}" , e)) ? ; let mut headers = std :: collections :: HashMap :: new () ; headers . insert ("Authorization" . to_string () , "Bearer {{ credential.token }}" . to_string ()) ; headers . insert ("Content-Type" . to_string () , "application/json" . to_string ()) ; let mut req_builder = match "POST" { "GET" => self . client . get (& url) , "POST" => self . client . post (& url) , "PUT" => self . client . put (& url) , "DELETE" => self . client . delete (& url) , "PATCH" => self . client . patch (& url) , _ => self . client . get (& url) , } ; for (k , v) in headers { let v_rendered = env . render_str (& v , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render header {}: {}" , k , e)) ? ; req_builder = req_builder . header (k , v_rendered) ; } let body_template = "{\"channel\":\"{{ input.channel }}\",\"text\":\"{{ input.text }}\"}" ; let body_rendered = env . render_str (body_template , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render body template: {}" , e)) ? ; let body_json : serde_json :: Value = serde_json :: from_str (& body_rendered) . map_err (| e | anyhow :: anyhow ! ("Failed to parse rendered body as JSON: {}" , e)) ? ; req_builder = req_builder . json (& body_json) ; match req_builder . send () . await { Ok (resp) => { let status = resp . status () . as_u16 () ; let body_bytes = resp . bytes () . await . unwrap_or_default () ; let body_json : serde_json :: Value = serde_json :: from_slice (& body_bytes) . unwrap_or_else (| _ | serde_json :: Value :: String (String :: from_utf8_lossy (& body_bytes) . to_string ())) ; let output = serde_json :: json ! ({ "status" : status , "body" : body_json , "original_input" : data }) ; if let Err (e) = tx . send (output) . await { eprintln ! ("Failed to send output: {}" , e) ; break ; } } Err (e) => { eprintln ! ("Request failed: {}" , e) ; } } } } } Ok (()) } } } pub mod notion { # [allow (unused_imports)] use super :: * ; pub struct NotionPageCreated { client : reqwest :: Client , } impl Default for NotionPageCreated { fn default () -> Self { Self :: new () } } impl NotionPageCreated { pub fn new () -> Self { Self { client : reqwest :: Client :: new () , } } } # [async_trait :: async_trait] impl crate :: stream_engine :: StreamNode for NotionPageCreated { async fn run (& self , # [allow (unused_mut)] # [allow (clippy :: possible_missing_else)] mut _inputs : Vec < tokio :: sync :: mpsc :: Receiver < serde_json :: Value >> , outputs : Vec < tokio :: sync :: mpsc :: Sender < serde_json :: Value >> ,) -> anyhow :: Result < () > { let mut seen_ids : std :: collections :: HashSet < String > = std :: collections :: HashSet :: new () ; let env : minijinja :: Environment = minijinja :: Environment :: new () ; let mut interval = tokio :: time :: interval (tokio :: time :: Duration :: from_millis (60000u64)) ; if let Some (tx) = outputs . first () { loop { interval . tick () . await ; let data : serde_json :: Value = serde_json :: Value :: Null ; let url_template = "https://api.notion.com/v1/search" ; let url = env . render_str (url_template , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render URL template: {}" , e)) ? ; let mut headers : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; headers . insert ("Notion-Version" . to_string () , "2022-06-28" . to_string ()) ; headers . insert ("Authorization" . to_string () , "Bearer {{ token }}" . to_string ()) ; headers . insert ("Content-Type" . to_string () , "application/json" . to_string ()) ; let mut req_builder : reqwest :: RequestBuilder = match "POST" { "GET" => self . client . get (& url) , "POST" => self . client . post (& url) , _ => self . client . get (& url) , } ; for (k , v) in headers { let v_rendered = env . render_str (& v , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render header {}: {}" , k , e)) ? ; req_builder = req_builder . header (k , v_rendered) ; } let body_template = "{\"filter\":{\"property\":\"object\",\"value\":\"page\"},\"sort\":{\"direction\":\"descending\",\"timestamp\":\"last_edited_time\"}}" ; let data = serde_json :: Value :: Null ; let body_rendered = env . render_str (body_template , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render body template: {}" , e)) ? ; let body_json : serde_json :: Value = serde_json :: from_str (& body_rendered) . map_err (| e | anyhow :: anyhow ! ("Failed to parse rendered body as JSON: {}" , e)) ? ; req_builder = req_builder . json (& body_json) ; match req_builder . send () . await { Ok (resp) => { let body_bytes = resp . bytes () . await . unwrap_or_default () ; let body_json : serde_json :: Value = serde_json :: from_slice (& body_bytes) . unwrap_or (serde_json :: Value :: Null) ; let items : Vec < serde_json :: Value > = body_json . get ("results") . and_then (| v | v . as_array ()) . cloned () . unwrap_or_default () ; for item in items { { let item_id : Option < String > = item . get ("id") . and_then (| v | v . as_str ()) . map (| s | s . to_string ()) ; if let Some (id) = item_id { if seen_ids . contains (& id) { continue ; } seen_ids . insert (id) ; } } if let Err (e) = tx . send (item) . await { eprintln ! ("Failed to send output: {}" , e) ; return Ok (()) ; } } } Err (e) => { eprintln ! ("Polling request failed: {}" , e) ; } } } } Ok (()) } } pub struct NotionNewComment { client : reqwest :: Client , } impl Default for NotionNewComment { fn default () -> Self { Self :: new () } } impl NotionNewComment { pub fn new () -> Self { Self { client : reqwest :: Client :: new () , } } } # [async_trait :: async_trait] impl crate :: stream_engine :: StreamNode for NotionNewComment { async fn run (& self , # [allow (unused_mut)] # [allow (clippy :: possible_missing_else)] mut _inputs : Vec < tokio :: sync :: mpsc :: Receiver < serde_json :: Value >> , outputs : Vec < tokio :: sync :: mpsc :: Sender < serde_json :: Value >> ,) -> anyhow :: Result < () > { let mut seen_ids : std :: collections :: HashSet < String > = std :: collections :: HashSet :: new () ; let env : minijinja :: Environment = minijinja :: Environment :: new () ; let mut interval = tokio :: time :: interval (tokio :: time :: Duration :: from_millis (60000u64)) ; if let Some (tx) = outputs . first () { loop { interval . tick () . await ; let data : serde_json :: Value = serde_json :: Value :: Null ; let url_template = "https://api.notion.com/v1/comments?block_id={{ block_id }}" ; let url = env . render_str (url_template , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render URL template: {}" , e)) ? ; let mut headers : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; headers . insert ("Notion-Version" . to_string () , "2022-06-28" . to_string ()) ; headers . insert ("Authorization" . to_string () , "Bearer {{ token }}" . to_string ()) ; let mut req_builder : reqwest :: RequestBuilder = match "GET" { "GET" => self . client . get (& url) , "POST" => self . client . post (& url) , _ => self . client . get (& url) , } ; for (k , v) in headers { let v_rendered = env . render_str (& v , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render header {}: {}" , k , e)) ? ; req_builder = req_builder . header (k , v_rendered) ; } match req_builder . send () . await { Ok (resp) => { let body_bytes = resp . bytes () . await . unwrap_or_default () ; let body_json : serde_json :: Value = serde_json :: from_slice (& body_bytes) . unwrap_or (serde_json :: Value :: Null) ; let items : Vec < serde_json :: Value > = body_json . get ("results") . and_then (| v | v . as_array ()) . cloned () . unwrap_or_default () ; for item in items { { let item_id : Option < String > = item . get ("id") . and_then (| v | v . as_str ()) . map (| s | s . to_string ()) ; if let Some (id) = item_id { if seen_ids . contains (& id) { continue ; } seen_ids . insert (id) ; } } if let Err (e) = tx . send (item) . await { eprintln ! ("Failed to send output: {}" , e) ; return Ok (()) ; } } } Err (e) => { eprintln ! ("Polling request failed: {}" , e) ; } } } } Ok (()) } } pub struct NotionCreatePage { client : reqwest :: Client , } impl Default for NotionCreatePage { fn default () -> Self { Self :: new () } } impl NotionCreatePage { pub fn new () -> Self { Self { client : reqwest :: Client :: new () , } } } # [async_trait :: async_trait] impl crate :: stream_engine :: StreamNode for NotionCreatePage { async fn run (& self , # [allow (unused_mut)] mut _inputs : Vec < tokio :: sync :: mpsc :: Receiver < serde_json :: Value >> , outputs : Vec < tokio :: sync :: mpsc :: Sender < serde_json :: Value >> ,) -> anyhow :: Result < () > { let env = minijinja :: Environment :: new () ; if let Some (rx) = _inputs . get_mut (0) { if let Some (tx) = outputs . first () { while let Some (data) = rx . recv () . await { let url_template = "https://api.notion.com/v1/pages" ; let url = env . render_str (url_template , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render URL template: {}" , e)) ? ; let mut headers = std :: collections :: HashMap :: new () ; headers . insert ("Notion-Version" . to_string () , "2022-06-28" . to_string ()) ; headers . insert ("Authorization" . to_string () , "Bearer {{ credential.token }}" . to_string ()) ; headers . insert ("Content-Type" . to_string () , "application/json" . to_string ()) ; let mut req_builder = match "POST" { "GET" => self . client . get (& url) , "POST" => self . client . post (& url) , "PUT" => self . client . put (& url) , "DELETE" => self . client . delete (& url) , "PATCH" => self . client . patch (& url) , _ => self . client . get (& url) , } ; for (k , v) in headers { let v_rendered = env . render_str (& v , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render header {}: {}" , k , e)) ? ; req_builder = req_builder . header (k , v_rendered) ; } let body_template = "{\"parent\":{\"database_id\":\"{{ input.database_id }}\"},\"properties\":{\"Name\":{\"title\":[{\"text\":{\"content\":\"{{ input.title }}\"}}]},\"Summary\":{\"rich_text\":[{\"text\":{\"content\":\"{{ input.summary }}\"}}]}}}" ; let body_rendered = env . render_str (body_template , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render body template: {}" , e)) ? ; let body_json : serde_json :: Value = serde_json :: from_str (& body_rendered) . map_err (| e | anyhow :: anyhow ! ("Failed to parse rendered body as JSON: {}" , e)) ? ; req_builder = req_builder . json (& body_json) ; match req_builder . send () . await { Ok (resp) => { let status = resp . status () . as_u16 () ; let body_bytes = resp . bytes () . await . unwrap_or_default () ; let body_json : serde_json :: Value = serde_json :: from_slice (& body_bytes) . unwrap_or_else (| _ | serde_json :: Value :: String (String :: from_utf8_lossy (& body_bytes) . to_string ())) ; let output = serde_json :: json ! ({ "status" : status , "body" : body_json , "original_input" : data }) ; if let Err (e) = tx . send (output) . await { eprintln ! ("Failed to send output: {}" , e) ; break ; } } Err (e) => { eprintln ! ("Request failed: {}" , e) ; } } } } } Ok (()) } } pub struct NotionRetrievePage { client : reqwest :: Client , } impl Default for NotionRetrievePage { fn default () -> Self { Self :: new () } } impl NotionRetrievePage { pub fn new () -> Self { Self { client : reqwest :: Client :: new () , } } } # [async_trait :: async_trait] impl crate :: stream_engine :: StreamNode for NotionRetrievePage { async fn run (& self , # [allow (unused_mut)] mut _inputs : Vec < tokio :: sync :: mpsc :: Receiver < serde_json :: Value >> , outputs : Vec < tokio :: sync :: mpsc :: Sender < serde_json :: Value >> ,) -> anyhow :: Result < () > { let env = minijinja :: Environment :: new () ; if let Some (rx) = _inputs . get_mut (0) { if let Some (tx) = outputs . first () { while let Some (data) = rx . recv () . await { let url_template = "https://api.notion.com/v1/pages/{{ input.page_id }}" ; let url = env . render_str (url_template , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render URL template: {}" , e)) ? ; let mut headers = std :: collections :: HashMap :: new () ; headers . insert ("Notion-Version" . to_string () , "2022-06-28" . to_string ()) ; headers . insert ("Authorization" . to_string () , "Bearer {{ credential.token }}" . to_string ()) ; let mut req_builder = match "GET" { "GET" => self . client . get (& url) , "POST" => self . client . post (& url) , "PUT" => self . client . put (& url) , "DELETE" => self . client . delete (& url) , "PATCH" => self . client . patch (& url) , _ => self . client . get (& url) , } ; for (k , v) in headers { let v_rendered = env . render_str (& v , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render header {}: {}" , k , e)) ? ; req_builder = req_builder . header (k , v_rendered) ; } match req_builder . send () . await { Ok (resp) => { let status = resp . status () . as_u16 () ; let body_bytes = resp . bytes () . await . unwrap_or_default () ; let body_json : serde_json :: Value = serde_json :: from_slice (& body_bytes) . unwrap_or_else (| _ | serde_json :: Value :: String (String :: from_utf8_lossy (& body_bytes) . to_string ())) ; let output = serde_json :: json ! ({ "status" : status , "body" : body_json , "original_input" : data }) ; if let Err (e) = tx . send (output) . await { eprintln ! ("Failed to send output: {}" , e) ; break ; } } Err (e) => { eprintln ! ("Request failed: {}" , e) ; } } } } } Ok (()) } } pub struct NotionUpdatePage { client : reqwest :: Client , } impl Default for NotionUpdatePage { fn default () -> Self { Self :: new () } } impl NotionUpdatePage { pub fn new () -> Self { Self { client : reqwest :: Client :: new () , } } } # [async_trait :: async_trait] impl crate :: stream_engine :: StreamNode for NotionUpdatePage { async fn run (& self , # [allow (unused_mut)] mut _inputs : Vec < tokio :: sync :: mpsc :: Receiver < serde_json :: Value >> , outputs : Vec < tokio :: sync :: mpsc :: Sender < serde_json :: Value >> ,) -> anyhow :: Result < () > { let env = minijinja :: Environment :: new () ; if let Some (rx) = _inputs . get_mut (0) { if let Some (tx) = outputs . first () { while let Some (data) = rx . recv () . await { let url_template = "https://api.notion.com/v1/pages/{{ input.page_id }}" ; let url = env . render_str (url_template , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render URL template: {}" , e)) ? ; let mut headers = std :: collections :: HashMap :: new () ; headers . insert ("Content-Type" . to_string () , "application/json" . to_string ()) ; headers . insert ("Authorization" . to_string () , "Bearer {{ credential.token }}" . to_string ()) ; headers . insert ("Notion-Version" . to_string () , "2022-06-28" . to_string ()) ; let mut req_builder = match "PATCH" { "GET" => self . client . get (& url) , "POST" => self . client . post (& url) , "PUT" => self . client . put (& url) , "DELETE" => self . client . delete (& url) , "PATCH" => self . client . patch (& url) , _ => self . client . get (& url) , } ; for (k , v) in headers { let v_rendered = env . render_str (& v , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render header {}: {}" , k , e)) ? ; req_builder = req_builder . header (k , v_rendered) ; } let body_template = "{\"archived\":\"{{ input.archived }}\",\"properties\":\"{{ input.properties }}\"}" ; let body_rendered = env . render_str (body_template , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render body template: {}" , e)) ? ; let body_json : serde_json :: Value = serde_json :: from_str (& body_rendered) . map_err (| e | anyhow :: anyhow ! ("Failed to parse rendered body as JSON: {}" , e)) ? ; req_builder = req_builder . json (& body_json) ; match req_builder . send () . await { Ok (resp) => { let status = resp . status () . as_u16 () ; let body_bytes = resp . bytes () . await . unwrap_or_default () ; let body_json : serde_json :: Value = serde_json :: from_slice (& body_bytes) . unwrap_or_else (| _ | serde_json :: Value :: String (String :: from_utf8_lossy (& body_bytes) . to_string ())) ; let output = serde_json :: json ! ({ "status" : status , "body" : body_json , "original_input" : data }) ; if let Err (e) = tx . send (output) . await { eprintln ! ("Failed to send output: {}" , e) ; break ; } } Err (e) => { eprintln ! ("Request failed: {}" , e) ; } } } } } Ok (()) } } pub struct NotionRetrieveBlockChildren { client : reqwest :: Client , } impl Default for NotionRetrieveBlockChildren { fn default () -> Self { Self :: new () } } impl NotionRetrieveBlockChildren { pub fn new () -> Self { Self { client : reqwest :: Client :: new () , } } } # [async_trait :: async_trait] impl crate :: stream_engine :: StreamNode for NotionRetrieveBlockChildren { async fn run (& self , # [allow (unused_mut)] mut _inputs : Vec < tokio :: sync :: mpsc :: Receiver < serde_json :: Value >> , outputs : Vec < tokio :: sync :: mpsc :: Sender < serde_json :: Value >> ,) -> anyhow :: Result < () > { let env = minijinja :: Environment :: new () ; if let Some (rx) = _inputs . get_mut (0) { if let Some (tx) = outputs . first () { while let Some (data) = rx . recv () . await { let url_template = "https://api.notion.com/v1/blocks/{{ input.block_id }}/children" ; let url = env . render_str (url_template , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render URL template: {}" , e)) ? ; let mut headers = std :: collections :: HashMap :: new () ; headers . insert ("Authorization" . to_string () , "Bearer {{ credential.token }}" . to_string ()) ; headers . insert ("Notion-Version" . to_string () , "2022-06-28" . to_string ()) ; let mut req_builder = match "GET" { "GET" => self . client . get (& url) , "POST" => self . client . post (& url) , "PUT" => self . client . put (& url) , "DELETE" => self . client . delete (& url) , "PATCH" => self . client . patch (& url) , _ => self . client . get (& url) , } ; for (k , v) in headers { let v_rendered = env . render_str (& v , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render header {}: {}" , k , e)) ? ; req_builder = req_builder . header (k , v_rendered) ; } match req_builder . send () . await { Ok (resp) => { let status = resp . status () . as_u16 () ; let body_bytes = resp . bytes () . await . unwrap_or_default () ; let body_json : serde_json :: Value = serde_json :: from_slice (& body_bytes) . unwrap_or_else (| _ | serde_json :: Value :: String (String :: from_utf8_lossy (& body_bytes) . to_string ())) ; let output = serde_json :: json ! ({ "status" : status , "body" : body_json , "original_input" : data }) ; if let Err (e) = tx . send (output) . await { eprintln ! ("Failed to send output: {}" , e) ; break ; } } Err (e) => { eprintln ! ("Request failed: {}" , e) ; } } } } } Ok (()) } } pub struct NotionAppendBlockChildren { client : reqwest :: Client , } impl Default for NotionAppendBlockChildren { fn default () -> Self { Self :: new () } } impl NotionAppendBlockChildren { pub fn new () -> Self { Self { client : reqwest :: Client :: new () , } } } # [async_trait :: async_trait] impl crate :: stream_engine :: StreamNode for NotionAppendBlockChildren { async fn run (& self , # [allow (unused_mut)] mut _inputs : Vec < tokio :: sync :: mpsc :: Receiver < serde_json :: Value >> , outputs : Vec < tokio :: sync :: mpsc :: Sender < serde_json :: Value >> ,) -> anyhow :: Result < () > { let env = minijinja :: Environment :: new () ; if let Some (rx) = _inputs . get_mut (0) { if let Some (tx) = outputs . first () { while let Some (data) = rx . recv () . await { let url_template = "https://api.notion.com/v1/blocks/{{ input.block_id }}/children" ; let url = env . render_str (url_template , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render URL template: {}" , e)) ? ; let mut headers = std :: collections :: HashMap :: new () ; headers . insert ("Notion-Version" . to_string () , "2022-06-28" . to_string ()) ; headers . insert ("Content-Type" . to_string () , "application/json" . to_string ()) ; headers . insert ("Authorization" . to_string () , "Bearer {{ credential.token }}" . to_string ()) ; let mut req_builder = match "PATCH" { "GET" => self . client . get (& url) , "POST" => self . client . post (& url) , "PUT" => self . client . put (& url) , "DELETE" => self . client . delete (& url) , "PATCH" => self . client . patch (& url) , _ => self . client . get (& url) , } ; for (k , v) in headers { let v_rendered = env . render_str (& v , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render header {}: {}" , k , e)) ? ; req_builder = req_builder . header (k , v_rendered) ; } let body_template = "{\"children\":\"{{ input.children }}\"}" ; let body_rendered = env . render_str (body_template , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render body template: {}" , e)) ? ; let body_json : serde_json :: Value = serde_json :: from_str (& body_rendered) . map_err (| e | anyhow :: anyhow ! ("Failed to parse rendered body as JSON: {}" , e)) ? ; req_builder = req_builder . json (& body_json) ; match req_builder . send () . await { Ok (resp) => { let status = resp . status () . as_u16 () ; let body_bytes = resp . bytes () . await . unwrap_or_default () ; let body_json : serde_json :: Value = serde_json :: from_slice (& body_bytes) . unwrap_or_else (| _ | serde_json :: Value :: String (String :: from_utf8_lossy (& body_bytes) . to_string ())) ; let output = serde_json :: json ! ({ "status" : status , "body" : body_json , "original_input" : data }) ; if let Err (e) = tx . send (output) . await { eprintln ! ("Failed to send output: {}" , e) ; break ; } } Err (e) => { eprintln ! ("Request failed: {}" , e) ; } } } } } Ok (()) } } pub struct NotionQueryDatabase { client : reqwest :: Client , } impl Default for NotionQueryDatabase { fn default () -> Self { Self :: new () } } impl NotionQueryDatabase { pub fn new () -> Self { Self { client : reqwest :: Client :: new () , } } } # [async_trait :: async_trait] impl crate :: stream_engine :: StreamNode for NotionQueryDatabase { async fn run (& self , # [allow (unused_mut)] mut _inputs : Vec < tokio :: sync :: mpsc :: Receiver < serde_json :: Value >> , outputs : Vec < tokio :: sync :: mpsc :: Sender < serde_json :: Value >> ,) -> anyhow :: Result < () > { let env = minijinja :: Environment :: new () ; if let Some (rx) = _inputs . get_mut (0) { if let Some (tx) = outputs . first () { while let Some (data) = rx . recv () . await { let url_template = "https://api.notion.com/v1/databases/{{ input.database_id }}/query" ; let url = env . render_str (url_template , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render URL template: {}" , e)) ? ; let mut headers = std :: collections :: HashMap :: new () ; headers . insert ("Content-Type" . to_string () , "application/json" . to_string ()) ; headers . insert ("Authorization" . to_string () , "Bearer {{ credential.token }}" . to_string ()) ; headers . insert ("Notion-Version" . to_string () , "2022-06-28" . to_string ()) ; let mut req_builder = match "POST" { "GET" => self . client . get (& url) , "POST" => self . client . post (& url) , "PUT" => self . client . put (& url) , "DELETE" => self . client . delete (& url) , "PATCH" => self . client . patch (& url) , _ => self . client . get (& url) , } ; for (k , v) in headers { let v_rendered = env . render_str (& v , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render header {}: {}" , k , e)) ? ; req_builder = req_builder . header (k , v_rendered) ; } let body_template = "{\"filter\":\"{{ input.filter }}\",\"sorts\":\"{{ input.sorts }}\"}" ; let body_rendered = env . render_str (body_template , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render body template: {}" , e)) ? ; let body_json : serde_json :: Value = serde_json :: from_str (& body_rendered) . map_err (| e | anyhow :: anyhow ! ("Failed to parse rendered body as JSON: {}" , e)) ? ; req_builder = req_builder . json (& body_json) ; match req_builder . send () . await { Ok (resp) => { let status = resp . status () . as_u16 () ; let body_bytes = resp . bytes () . await . unwrap_or_default () ; let body_json : serde_json :: Value = serde_json :: from_slice (& body_bytes) . unwrap_or_else (| _ | serde_json :: Value :: String (String :: from_utf8_lossy (& body_bytes) . to_string ())) ; let output = serde_json :: json ! ({ "status" : status , "body" : body_json , "original_input" : data }) ; if let Err (e) = tx . send (output) . await { eprintln ! ("Failed to send output: {}" , e) ; break ; } } Err (e) => { eprintln ! ("Request failed: {}" , e) ; } } } } } Ok (()) } } pub struct NotionRetrieveDatabase { client : reqwest :: Client , } impl Default for NotionRetrieveDatabase { fn default () -> Self { Self :: new () } } impl NotionRetrieveDatabase { pub fn new () -> Self { Self { client : reqwest :: Client :: new () , } } } # [async_trait :: async_trait] impl crate :: stream_engine :: StreamNode for NotionRetrieveDatabase { async fn run (& self , # [allow (unused_mut)] mut _inputs : Vec < tokio :: sync :: mpsc :: Receiver < serde_json :: Value >> , outputs : Vec < tokio :: sync :: mpsc :: Sender < serde_json :: Value >> ,) -> anyhow :: Result < () > { let env = minijinja :: Environment :: new () ; if let Some (rx) = _inputs . get_mut (0) { if let Some (tx) = outputs . first () { while let Some (data) = rx . recv () . await { let url_template = "https://api.notion.com/v1/databases/{{ input.database_id }}" ; let url = env . render_str (url_template , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render URL template: {}" , e)) ? ; let mut headers = std :: collections :: HashMap :: new () ; headers . insert ("Authorization" . to_string () , "Bearer {{ credential.token }}" . to_string ()) ; headers . insert ("Notion-Version" . to_string () , "2022-06-28" . to_string ()) ; let mut req_builder = match "GET" { "GET" => self . client . get (& url) , "POST" => self . client . post (& url) , "PUT" => self . client . put (& url) , "DELETE" => self . client . delete (& url) , "PATCH" => self . client . patch (& url) , _ => self . client . get (& url) , } ; for (k , v) in headers { let v_rendered = env . render_str (& v , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render header {}: {}" , k , e)) ? ; req_builder = req_builder . header (k , v_rendered) ; } match req_builder . send () . await { Ok (resp) => { let status = resp . status () . as_u16 () ; let body_bytes = resp . bytes () . await . unwrap_or_default () ; let body_json : serde_json :: Value = serde_json :: from_slice (& body_bytes) . unwrap_or_else (| _ | serde_json :: Value :: String (String :: from_utf8_lossy (& body_bytes) . to_string ())) ; let output = serde_json :: json ! ({ "status" : status , "body" : body_json , "original_input" : data }) ; if let Err (e) = tx . send (output) . await { eprintln ! ("Failed to send output: {}" , e) ; break ; } } Err (e) => { eprintln ! ("Request failed: {}" , e) ; } } } } } Ok (()) } } pub struct NotionSearch { client : reqwest :: Client , } impl Default for NotionSearch { fn default () -> Self { Self :: new () } } impl NotionSearch { pub fn new () -> Self { Self { client : reqwest :: Client :: new () , } } } # [async_trait :: async_trait] impl crate :: stream_engine :: StreamNode for NotionSearch { async fn run (& self , # [allow (unused_mut)] mut _inputs : Vec < tokio :: sync :: mpsc :: Receiver < serde_json :: Value >> , outputs : Vec < tokio :: sync :: mpsc :: Sender < serde_json :: Value >> ,) -> anyhow :: Result < () > { let env = minijinja :: Environment :: new () ; if let Some (rx) = _inputs . get_mut (0) { if let Some (tx) = outputs . first () { while let Some (data) = rx . recv () . await { let url_template = "https://api.notion.com/v1/search" ; let url = env . render_str (url_template , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render URL template: {}" , e)) ? ; let mut headers = std :: collections :: HashMap :: new () ; headers . insert ("Content-Type" . to_string () , "application/json" . to_string ()) ; headers . insert ("Authorization" . to_string () , "Bearer {{ credential.token }}" . to_string ()) ; headers . insert ("Notion-Version" . to_string () , "2022-06-28" . to_string ()) ; let mut req_builder = match "POST" { "GET" => self . client . get (& url) , "POST" => self . client . post (& url) , "PUT" => self . client . put (& url) , "DELETE" => self . client . delete (& url) , "PATCH" => self . client . patch (& url) , _ => self . client . get (& url) , } ; for (k , v) in headers { let v_rendered = env . render_str (& v , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render header {}: {}" , k , e)) ? ; req_builder = req_builder . header (k , v_rendered) ; } let body_template = "{\"filter\":\"{{ input.filter }}\",\"query\":\"{{ input.query }}\",\"sort\":\"{{ input.sort }}\"}" ; let body_rendered = env . render_str (body_template , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render body template: {}" , e)) ? ; let body_json : serde_json :: Value = serde_json :: from_str (& body_rendered) . map_err (| e | anyhow :: anyhow ! ("Failed to parse rendered body as JSON: {}" , e)) ? ; req_builder = req_builder . json (& body_json) ; match req_builder . send () . await { Ok (resp) => { let status = resp . status () . as_u16 () ; let body_bytes = resp . bytes () . await . unwrap_or_default () ; let body_json : serde_json :: Value = serde_json :: from_slice (& body_bytes) . unwrap_or_else (| _ | serde_json :: Value :: String (String :: from_utf8_lossy (& body_bytes) . to_string ())) ; let output = serde_json :: json ! ({ "status" : status , "body" : body_json , "original_input" : data }) ; if let Err (e) = tx . send (output) . await { eprintln ! ("Failed to send output: {}" , e) ; break ; } } Err (e) => { eprintln ! ("Request failed: {}" , e) ; } } } } } Ok (()) } } pub struct NotionListUsers { client : reqwest :: Client , } impl Default for NotionListUsers { fn default () -> Self { Self :: new () } } impl NotionListUsers { pub fn new () -> Self { Self { client : reqwest :: Client :: new () , } } } # [async_trait :: async_trait] impl crate :: stream_engine :: StreamNode for NotionListUsers { async fn run (& self , # [allow (unused_mut)] mut _inputs : Vec < tokio :: sync :: mpsc :: Receiver < serde_json :: Value >> , outputs : Vec < tokio :: sync :: mpsc :: Sender < serde_json :: Value >> ,) -> anyhow :: Result < () > { let env = minijinja :: Environment :: new () ; if let Some (rx) = _inputs . get_mut (0) { if let Some (tx) = outputs . first () { while let Some (data) = rx . recv () . await { let url_template = "https://api.notion.com/v1/users" ; let url = env . render_str (url_template , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render URL template: {}" , e)) ? ; let mut headers = std :: collections :: HashMap :: new () ; headers . insert ("Notion-Version" . to_string () , "2022-06-28" . to_string ()) ; headers . insert ("Authorization" . to_string () , "Bearer {{ credential.token }}" . to_string ()) ; let mut req_builder = match "GET" { "GET" => self . client . get (& url) , "POST" => self . client . post (& url) , "PUT" => self . client . put (& url) , "DELETE" => self . client . delete (& url) , "PATCH" => self . client . patch (& url) , _ => self . client . get (& url) , } ; for (k , v) in headers { let v_rendered = env . render_str (& v , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render header {}: {}" , k , e)) ? ; req_builder = req_builder . header (k , v_rendered) ; } match req_builder . send () . await { Ok (resp) => { let status = resp . status () . as_u16 () ; let body_bytes = resp . bytes () . await . unwrap_or_default () ; let body_json : serde_json :: Value = serde_json :: from_slice (& body_bytes) . unwrap_or_else (| _ | serde_json :: Value :: String (String :: from_utf8_lossy (& body_bytes) . to_string ())) ; let output = serde_json :: json ! ({ "status" : status , "body" : body_json , "original_input" : data }) ; if let Err (e) = tx . send (output) . await { eprintln ! ("Failed to send output: {}" , e) ; break ; } } Err (e) => { eprintln ! ("Request failed: {}" , e) ; } } } } } Ok (()) } } pub struct NotionRetrieveUser { client : reqwest :: Client , } impl Default for NotionRetrieveUser { fn default () -> Self { Self :: new () } } impl NotionRetrieveUser { pub fn new () -> Self { Self { client : reqwest :: Client :: new () , } } } # [async_trait :: async_trait] impl crate :: stream_engine :: StreamNode for NotionRetrieveUser { async fn run (& self , # [allow (unused_mut)] mut _inputs : Vec < tokio :: sync :: mpsc :: Receiver < serde_json :: Value >> , outputs : Vec < tokio :: sync :: mpsc :: Sender < serde_json :: Value >> ,) -> anyhow :: Result < () > { let env = minijinja :: Environment :: new () ; if let Some (rx) = _inputs . get_mut (0) { if let Some (tx) = outputs . first () { while let Some (data) = rx . recv () . await { let url_template = "https://api.notion.com/v1/users/{{ input.user_id }}" ; let url = env . render_str (url_template , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render URL template: {}" , e)) ? ; let mut headers = std :: collections :: HashMap :: new () ; headers . insert ("Authorization" . to_string () , "Bearer {{ credential.token }}" . to_string ()) ; headers . insert ("Notion-Version" . to_string () , "2022-06-28" . to_string ()) ; let mut req_builder = match "GET" { "GET" => self . client . get (& url) , "POST" => self . client . post (& url) , "PUT" => self . client . put (& url) , "DELETE" => self . client . delete (& url) , "PATCH" => self . client . patch (& url) , _ => self . client . get (& url) , } ; for (k , v) in headers { let v_rendered = env . render_str (& v , & data) . map_err (| e | anyhow :: anyhow ! ("Failed to render header {}: {}" , k , e)) ? ; req_builder = req_builder . header (k , v_rendered) ; } match req_builder . send () . await { Ok (resp) => { let status = resp . status () . as_u16 () ; let body_bytes = resp . bytes () . await . unwrap_or_default () ; let body_json : serde_json :: Value = serde_json :: from_slice (& body_bytes) . unwrap_or_else (| _ | serde_json :: Value :: String (String :: from_utf8_lossy (& body_bytes) . to_string ())) ; let output = serde_json :: json ! ({ "status" : status , "body" : body_json , "original_input" : data }) ; if let Err (e) = tx . send (output) . await { eprintln ! ("Failed to send output: {}" , e) ; break ; } } Err (e) => { eprintln ! ("Request failed: {}" , e) ; } } } } } Ok (()) } } } pub fn create_integration_node (integration : & str , node : & str) -> Option < Box < dyn crate :: stream_engine :: StreamNode >> { match (integration , node) { ("Slack" , "Post Message") => Some (Box :: new (slack :: SlackPostMessage :: new ())) , ("Notion" , "Page Created") => Some (Box :: new (notion :: NotionPageCreated :: new ())) , ("Notion" , "New Comment") => Some (Box :: new (notion :: NotionNewComment :: new ())) , ("Notion" , "Create Page") => Some (Box :: new (notion :: NotionCreatePage :: new ())) , ("Notion" , "Retrieve Page") => Some (Box :: new (notion :: NotionRetrievePage :: new ())) , ("Notion" , "Update Page") => Some (Box :: new (notion :: NotionUpdatePage :: new ())) , ("Notion" , "Retrieve Block Children") => Some (Box :: new (notion :: NotionRetrieveBlockChildren :: new ())) , ("Notion" , "Append Block Children") => Some (Box :: new (notion :: NotionAppendBlockChildren :: new ())) , ("Notion" , "Query Database") => Some (Box :: new (notion :: NotionQueryDatabase :: new ())) , ("Notion" , "Retrieve Database") => Some (Box :: new (notion :: NotionRetrieveDatabase :: new ())) , ("Notion" , "Search") => Some (Box :: new (notion :: NotionSearch :: new ())) , ("Notion" , "List Users") => Some (Box :: new (notion :: NotionListUsers :: new ())) , ("Notion" , "Retrieve User") => Some (Box :: new (notion :: NotionRetrieveUser :: new ())) , _ => None , } } pub fn get_integration_node_definitions () -> Vec < crate :: node_registry :: NodeType > { vec ! [crate :: node_registry :: NodeType { id : "slack_post_message" . to_string () , label : "Slack: Post Message" . to_string () , category : "Integration" . to_string () , description : Some ("Slack integration" . to_string ()) , documentation : Some ("Posts a message to a Slack channel.\n\n### Properties\n- **credential_id**: The ID of the Slack credential to use.\n- **channel**: The channel ID or name to post to.\n- **text**: The message text to post.\n" . to_string ()) , properties : vec ! [crate :: node_registry :: NodeProperty { name : "credential_id" . to_string () , label : "Credential ID" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : true , json_schema : None , } , crate :: node_registry :: NodeProperty { name : "channel" . to_string () , label : "Channel" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : true , json_schema : None , } , crate :: node_registry :: NodeProperty { name : "text" . to_string () , label : "Message Text" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : true , json_schema : None , }] , } , crate :: node_registry :: NodeType { id : "notion_page_created" . to_string () , label : "Notion: Page Created" . to_string () , category : "Integration" . to_string () , description : Some ("Notion integration" . to_string ()) , documentation : Some ("Triggers when a new page is created in the workspace.\nPolls the Notion Search API every 60 seconds.\n" . to_string ()) , properties : vec ! [] , } , crate :: node_registry :: NodeType { id : "notion_new_comment" . to_string () , label : "Notion: New Comment" . to_string () , category : "Integration" . to_string () , description : Some ("Notion integration" . to_string ()) , documentation : Some ("Triggers when a new comment is added.\nPolls the Notion Comments API every 60 seconds.\n" . to_string ()) , properties : vec ! [crate :: node_registry :: NodeProperty { name : "block_id" . to_string () , label : "Block/Page ID" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : true , json_schema : None , }] , } , crate :: node_registry :: NodeType { id : "notion_create_page" . to_string () , label : "Notion: Create Page" . to_string () , category : "Integration" . to_string () , description : Some ("Notion integration" . to_string ()) , documentation : Some ("Creates a new page in a Notion database.\n\n### Properties\n- **credential_id**: The ID of the Notion credential to use.\n- **database_id**: The ID of the database to create the page in.\n- **title**: The title of the new page.\n- **summary**: A summary of the page content.\n" . to_string ()) , properties : vec ! [crate :: node_registry :: NodeProperty { name : "credential_id" . to_string () , label : "Credential ID" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : true , json_schema : None , } , crate :: node_registry :: NodeProperty { name : "database_id" . to_string () , label : "Database ID" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : true , json_schema : None , } , crate :: node_registry :: NodeProperty { name : "title" . to_string () , label : "Title" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : true , json_schema : None , } , crate :: node_registry :: NodeProperty { name : "summary" . to_string () , label : "Summary" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : false , json_schema : None , }] , } , crate :: node_registry :: NodeType { id : "notion_retrieve_page" . to_string () , label : "Notion: Retrieve Page" . to_string () , category : "Integration" . to_string () , description : Some ("Notion integration" . to_string ()) , documentation : Some ("Retrieves a page from Notion.\n\n### Properties\n- **credential_id**: The ID of the Notion credential to use.\n- **page_id**: The ID of the page to retrieve.\n" . to_string ()) , properties : vec ! [crate :: node_registry :: NodeProperty { name : "credential_id" . to_string () , label : "Credential ID" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : true , json_schema : None , } , crate :: node_registry :: NodeProperty { name : "page_id" . to_string () , label : "Page ID" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : true , json_schema : None , }] , } , crate :: node_registry :: NodeType { id : "notion_update_page" . to_string () , label : "Notion: Update Page" . to_string () , category : "Integration" . to_string () , description : Some ("Notion integration" . to_string ()) , documentation : Some ("Updates a page in Notion.\n\n### Properties\n- **credential_id**: The ID of the Notion credential to use.\n- **page_id**: The ID of the page to update.\n- **properties**: JSON object of properties to update.\n- **archived**: Boolean indicating whether to archive the page.\n" . to_string ()) , properties : vec ! [crate :: node_registry :: NodeProperty { name : "credential_id" . to_string () , label : "Credential ID" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : true , json_schema : None , } , crate :: node_registry :: NodeProperty { name : "page_id" . to_string () , label : "Page ID" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : true , json_schema : None , } , crate :: node_registry :: NodeProperty { name : "properties" . to_string () , label : "Properties (JSON)" . to_string () , property_type : "json" . to_string () , options : None , default : None , required : false , json_schema : None , } , crate :: node_registry :: NodeProperty { name : "archived" . to_string () , label : "Archived" . to_string () , property_type : "boolean" . to_string () , options : None , default : None , required : false , json_schema : None , }] , } , crate :: node_registry :: NodeType { id : "notion_retrieve_block_children" . to_string () , label : "Notion: Retrieve Block Children" . to_string () , category : "Integration" . to_string () , description : Some ("Notion integration" . to_string ()) , documentation : Some ("Retrieves the children of a block.\n\n### Properties\n- **credential_id**: The ID of the Notion credential to use.\n- **block_id**: The ID of the block to retrieve children for.\n" . to_string ()) , properties : vec ! [crate :: node_registry :: NodeProperty { name : "credential_id" . to_string () , label : "Credential ID" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : true , json_schema : None , } , crate :: node_registry :: NodeProperty { name : "block_id" . to_string () , label : "Block ID" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : true , json_schema : None , }] , } , crate :: node_registry :: NodeType { id : "notion_append_block_children" . to_string () , label : "Notion: Append Block Children" . to_string () , category : "Integration" . to_string () , description : Some ("Notion integration" . to_string ()) , documentation : Some ("Appends children to a block.\n\n### Properties\n- **credential_id**: The ID of the Notion credential to use.\n- **block_id**: The ID of the block to append children to.\n- **children**: JSON array of block objects to append.\n" . to_string ()) , properties : vec ! [crate :: node_registry :: NodeProperty { name : "credential_id" . to_string () , label : "Credential ID" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : true , json_schema : None , } , crate :: node_registry :: NodeProperty { name : "block_id" . to_string () , label : "Block ID" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : true , json_schema : None , } , crate :: node_registry :: NodeProperty { name : "children" . to_string () , label : "Children (JSON)" . to_string () , property_type : "json" . to_string () , options : None , default : None , required : true , json_schema : None , }] , } , crate :: node_registry :: NodeType { id : "notion_query_database" . to_string () , label : "Notion: Query Database" . to_string () , category : "Integration" . to_string () , description : Some ("Notion integration" . to_string ()) , documentation : Some ("Queries a database.\n\n### Properties\n- **credential_id**: The ID of the Notion credential to use.\n- **database_id**: The ID of the database to query.\n- **filter**: JSON object for filtering results.\n- **sorts**: JSON array for sorting results.\n" . to_string ()) , properties : vec ! [crate :: node_registry :: NodeProperty { name : "credential_id" . to_string () , label : "Credential ID" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : true , json_schema : None , } , crate :: node_registry :: NodeProperty { name : "database_id" . to_string () , label : "Database ID" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : true , json_schema : None , } , crate :: node_registry :: NodeProperty { name : "filter" . to_string () , label : "Filter (JSON)" . to_string () , property_type : "json" . to_string () , options : None , default : None , required : false , json_schema : None , } , crate :: node_registry :: NodeProperty { name : "sorts" . to_string () , label : "Sorts (JSON)" . to_string () , property_type : "json" . to_string () , options : None , default : None , required : false , json_schema : None , }] , } , crate :: node_registry :: NodeType { id : "notion_retrieve_database" . to_string () , label : "Notion: Retrieve Database" . to_string () , category : "Integration" . to_string () , description : Some ("Notion integration" . to_string ()) , documentation : Some ("Retrieves a database.\n\n### Properties\n- **credential_id**: The ID of the Notion credential to use.\n- **database_id**: The ID of the database to retrieve.\n" . to_string ()) , properties : vec ! [crate :: node_registry :: NodeProperty { name : "credential_id" . to_string () , label : "Credential ID" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : true , json_schema : None , } , crate :: node_registry :: NodeProperty { name : "database_id" . to_string () , label : "Database ID" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : true , json_schema : None , }] , } , crate :: node_registry :: NodeType { id : "notion_search" . to_string () , label : "Notion: Search" . to_string () , category : "Integration" . to_string () , description : Some ("Notion integration" . to_string ()) , documentation : Some ("Searches for pages or databases.\n\n### Properties\n- **credential_id**: The ID of the Notion credential to use.\n- **query**: The search query string.\n" . to_string ()) , properties : vec ! [crate :: node_registry :: NodeProperty { name : "credential_id" . to_string () , label : "Credential ID" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : true , json_schema : None , } , crate :: node_registry :: NodeProperty { name : "query" . to_string () , label : "Search Query" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : false , json_schema : None , }] , } , crate :: node_registry :: NodeType { id : "notion_list_users" . to_string () , label : "Notion: List Users" . to_string () , category : "Integration" . to_string () , description : Some ("Notion integration" . to_string ()) , documentation : Some ("Lists all users.\n\n### Properties\n- **credential_id**: The ID of the Notion credential to use.\n" . to_string ()) , properties : vec ! [crate :: node_registry :: NodeProperty { name : "credential_id" . to_string () , label : "Credential ID" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : true , json_schema : None , }] , } , crate :: node_registry :: NodeType { id : "notion_retrieve_user" . to_string () , label : "Notion: Retrieve User" . to_string () , category : "Integration" . to_string () , description : Some ("Notion integration" . to_string ()) , documentation : Some ("Retrieves a user.\n\n### Properties\n- **credential_id**: The ID of the Notion credential to use.\n- **user_id**: The ID of the user to retrieve.\n" . to_string ()) , properties : vec ! [crate :: node_registry :: NodeProperty { name : "credential_id" . to_string () , label : "Credential ID" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : true , json_schema : None , } , crate :: node_registry :: NodeProperty { name : "user_id" . to_string () , label : "User ID" . to_string () , property_type : "text" . to_string () , options : None , default : None , required : true , json_schema : None , }] , }] }
  |

error: could not compile `rust_flow` (lib) due to 1 previous error
